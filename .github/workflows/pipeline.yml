name: Pipeline (CI â†’ Security â†’ Deploy â†’ DAST)

on:
  push:
    branches: [ "**" ]          # CI & SAST on every branch
  pull_request:                  # CI & SAST on PRs
  workflow_dispatch:             # allow manual run

permissions:
  contents: read
  security-events: write
  packages: write

concurrency:
  group: pipeline-${{ github.ref }}
  cancel-in-progress: false

env:
  DEPLOY_PATH: ${{ vars.DEPLOY_PATH || '/srv/dvwa' }}
  POST_DEPLOY_CMD: ${{ vars.POST_DEPLOY_CMD || '' }}

jobs:
  # ---------------- CI ----------------
  ci:
    name: Unit / Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      # TODO: replace with your real build/tests
      - run: echo "run your tests here"

  # -------------- SAST (Semgrep) --------------
  semgrep:
    runs-on: ubuntu-latest
    needs: [ci]
    steps:
      - uses: actions/checkout@v4
      - name: Run Semgrep
        run: |
          python -m pip install semgrep
          
          # Create reports directory
          mkdir -p semgrep-reports
          
          # Generate SARIF format for GitHub Security tab
          echo "ðŸ” Running Semgrep scan for SARIF..."
          semgrep --config=auto --sarif --output=semgrep-reports/semgrep.sarif . || echo "Semgrep SARIF scan completed"
          
          # Generate JSON format for detailed analysis
          echo "ðŸ” Running Semgrep scan for JSON..."
          semgrep --config=auto --json --output=semgrep-reports/semgrep.json . || echo "Semgrep JSON scan completed"
          
          # Generate text format for human reading
          echo "ðŸ” Running Semgrep scan for text..."
          semgrep --config=auto --text --output=semgrep-reports/semgrep.txt . || echo "Semgrep text scan completed"
          
          # Copy SARIF to root for GitHub Security upload
          cp semgrep-reports/semgrep.sarif semgrep.sarif 2>/dev/null || echo "SARIF copy failed"
          
          # Show what was generated
          echo "ðŸ“Š Generated reports:"
          ls -la semgrep-reports/ || echo "No reports directory found"
          ls -la semgrep.* 2>/dev/null || echo "No root level reports found"
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif
        if: always() && hashFiles('semgrep.sarif') != ''
      - name: Upload Semgrep Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: semgrep-reports
          path: |
            semgrep-reports/
            semgrep.sarif
          if-no-files-found: warn
          retention-days: 30

  # -------------- IaC (tfsec) --------------
  tfsec:
    runs-on: ubuntu-latest
    needs: [ci]
    steps:
      - uses: actions/checkout@v4
      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          format: json
          soft_fail: true
      - name: Generate additional tfsec reports
        run: |
          # Install tfsec if not available
          if ! command -v tfsec &> /dev/null; then
            curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
          fi
          # Generate multiple report formats
          tfsec . --format json --out tfsec.json --soft-fail || echo "tfsec scan completed"
          tfsec . --format sarif --out tfsec.sarif --soft-fail || echo "tfsec SARIF generated"
          tfsec . --format text --out tfsec.txt --soft-fail || echo "tfsec text report generated"
        continue-on-error: true
      - name: Upload tfsec Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: tfsec-reports
          path: |
            tfsec.json
            tfsec.sarif
            tfsec.txt
          if-no-files-found: warn
          retention-days: 30

  # -------------- CodeQL --------------
  codeql:
    runs-on: ubuntu-latest
    needs: [ci]
    strategy:
      fail-fast: false
      matrix:
        language: [ 'javascript' ]   # PHP not supported by CodeQL
    steps:
      - uses: actions/checkout@v4
      - uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
      - uses: github/codeql-action/autobuild@v3
      - uses: github/codeql-action/analyze@v3
        with:
          upload: true
          output: codeql-results
      - name: Upload CodeQL Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: codeql-results-${{ matrix.language }}
          path: codeql-results
          if-no-files-found: warn
          retention-days: 30

  # -------------- Container Build & Scan --------------
  container:
    name: Build image & Trivy scan
    runs-on: ubuntu-latest
    needs: [semgrep, tfsec, codeql]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    steps:
      - uses: actions/checkout@v4
      - name: Build image
        run: docker build -t app:ci .
      - name: Trivy scan (SARIF)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: app:ci
          format: sarif
          output: trivy.sarif
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
      - name: Trivy scan (JSON)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: app:ci
          format: json
          output: trivy.json
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
      - name: Trivy scan (Table)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: app:ci
          format: table
          output: trivy.txt
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
      - uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy.sarif
      - name: Upload Trivy Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: trivy-reports
          path: |
            trivy.sarif
            trivy.json
            trivy.txt
          if-no-files-found: warn
          retention-days: 30

  # -------------- Deploy --------------
  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    needs: [container]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    env:
      VPS_HOST: ${{ secrets.VPS_HOST }}
      VPS_PORT: ${{ secrets.VPS_PORT }}
      VPS_USER: ${{ secrets.VPS_USER }}
      VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
    steps:
      - uses: actions/checkout@v4

      - name: Install rsync, ssh client & sshpass
        run: |
          sudo apt-get update
          sudo apt-get install -y rsync openssh-client sshpass

      - name: Configure SSH
        run: |
          # Create SSH directory with proper permissions
          install -m 700 -d ~/.ssh
          
          # Add host to known_hosts (disable host key checking for password auth)
          ssh-keyscan -p "${VPS_PORT:-22}" "$VPS_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Create SSH config to disable strict host key checking
          cat << EOF > ~/.ssh/config
          Host *
              StrictHostKeyChecking no
              UserKnownHostsFile /dev/null
              LogLevel QUIET
          EOF
          chmod 600 ~/.ssh/config
          
          # Test SSH connection with password
          echo "Testing SSH connection with password authentication..."
          sshpass -p "$VPS_PASSWORD" ssh -o ConnectTimeout=10 -p "${VPS_PORT:-22}" "$VPS_USER@$VPS_HOST" "echo 'SSH connection successful'" || echo "SSH test failed - will retry in next step"

      - name: Ensure remote dir & rsync present
        run: |
          sshpass -p "$VPS_PASSWORD" ssh -o ConnectTimeout=30 -p "${VPS_PORT:-22}" "$VPS_USER@$VPS_HOST" "\
            mkdir -p '$DEPLOY_PATH' && \
            ( command -v rsync >/dev/null 2>&1 || \
              (sudo apt-get update && sudo apt-get install -y rsync) || \
              (which yum >/dev/null 2>&1 && sudo yum install -y rsync) || true )"

      - name: Rsync deploy
        run: |
          rsync -az --delete \
            --exclude '.git' \
            --exclude '.github' \
            -e "sshpass -p '$VPS_PASSWORD' ssh -o ConnectTimeout=30 -p ${VPS_PORT:-22}" \
            ./ "$VPS_USER@$VPS_HOST:$DEPLOY_PATH/"

      - name: Deploy Docker Container
        run: |
          echo "ðŸ³ Deploying Docker container on VPS..."
          sshpass -p "$VPS_PASSWORD" ssh -o ConnectTimeout=30 -p "${VPS_PORT:-22}" "$VPS_USER@$VPS_HOST" "\
            cd '$DEPLOY_PATH' && \
            echo 'ðŸ›‘ Stopping existing container if running...' && \
            docker stop dvwa-app 2>/dev/null || true && \
            docker rm dvwa-app 2>/dev/null || true && \
            echo 'ðŸ—ï¸ Building Docker image...' && \
            docker build -t dvwa-app:latest . && \
            echo 'ðŸš€ Starting container on port 80...' && \
            docker run -d --name dvwa-app -p 80:80 dvwa-app:latest && \
            echo 'âœ… Container started successfully' && \
            echo 'ðŸ“Š Container status:' && \
            docker ps | grep dvwa-app && \
            echo 'â³ Waiting for health check to pass (start-period: 5s)...' && \
            sleep 10 && \
            echo 'ðŸ” Checking container health status...' && \
            docker inspect dvwa-app --format='{{.State.Health.Status}}' || echo 'No health status yet' && \
            echo 'ðŸ“‹ Container logs:' && \
            docker logs dvwa-app --tail 15"

      - name: Wait for Container Health
        run: |
          echo "ðŸ¥ Waiting for container to become healthy..."
          sshpass -p "$VPS_PASSWORD" ssh -o ConnectTimeout=30 -p "${VPS_PORT:-22}" "$VPS_USER@$VPS_HOST" "\
            echo 'â³ Waiting for Docker health check to pass...' && \
            timeout=60 && \
            elapsed=0 && \
            while [ \$elapsed -lt \$timeout ]; do \
              health_status=\$(docker inspect dvwa-app --format='{{.State.Health.Status}}' 2>/dev/null || echo 'none') && \
              echo \"Health status (\${elapsed}s): \$health_status\" && \
              if [ \"\$health_status\" = \"healthy\" ]; then \
                echo 'âœ… Container is healthy!' && \
                break; \
              elif [ \"\$health_status\" = \"unhealthy\" ]; then \
                echo 'âŒ Container is unhealthy, checking logs...' && \
                docker logs dvwa-app --tail 10 && \
                break; \
              fi && \
              sleep 5 && \
              elapsed=\$((elapsed + 5)); \
            done && \
            echo '' && \
            echo 'ðŸŒ Testing external connectivity...' && \
            curl -I http://localhost/ 2>/dev/null || echo 'External curl failed' && \
            echo 'ðŸ“Š Final container status:' && \
            docker ps | grep dvwa-app"

      - name: Post-deploy (optional)
        run: |
          if [ -n "${POST_DEPLOY_CMD:-}" ]; then
            echo "Running post-deploy: $POST_DEPLOY_CMD"
            sshpass -p "$VPS_PASSWORD" ssh -o ConnectTimeout=30 -p "${VPS_PORT:-22}" "$VPS_USER@$VPS_HOST" "$POST_DEPLOY_CMD"
          else
            echo "No additional post-deploy commands set."
          fi

  # -------------- DAST (ZAP) --------------
  dast:
    name: ZAP Baseline
    runs-on: ubuntu-latest
    needs: [deploy]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    env:
      VPS_HOST: ${{ secrets.VPS_HOST }}
      VPS_PORT: ${{ secrets.VPS_PORT }}
    steps:
      - name: Prepare ZAP Target URL
        run: |
          # Auto-derive target URL from VPS_HOST
          if [ -z "$VPS_HOST" ]; then
            echo "âŒ VPS_HOST secret is not set"
            echo "Please set VPS_HOST secret to your VPS IP address"
            exit 1
          fi
          
          # Set target URL to VPS IP on port 80
          TARGET_URL="http://${VPS_HOST}"
          echo "TARGET_URL=$TARGET_URL" >> $GITHUB_ENV
          echo "âœ… ZAP Target URL auto-derived: $TARGET_URL"
          
          # Quick wait since container should already be healthy
          echo "â³ Brief wait for deployment to settle (container should be healthy by now)..."
          sleep 10
          
          # Test if target is reachable (should work since health check passed)
          echo "ðŸ” Testing target reachability..."
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "ðŸŒ Attempt $attempt/$max_attempts: Testing $TARGET_URL"
            response=$(curl -s --connect-timeout 10 --max-time 30 -I "$TARGET_URL" 2>&1)
            if echo "$response" | grep -q "HTTP"; then
              echo "âœ… Target is reachable! Response:"
              echo "$response" | head -3
              break
            else
              echo "âš ï¸ Target not reachable yet. Response/Error:"
              echo "$response" | head -2
              if [ $attempt -lt $max_attempts ]; then
                echo "â³ Waiting 10 seconds before next attempt..."
                sleep 10
              fi
              attempt=$((attempt + 1))
            fi
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "âŒ Target not reachable after $max_attempts attempts"
            echo "ðŸ”§ This is unexpected since container health check should have passed"
            echo "ðŸ“Š Continuing with scan for debugging..."
          fi

      - name: Run ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.12.0
        with:
          target: ${{ env.TARGET_URL }}
          fail_action: false
          cmd_options: >-
            -a -m 5 -T 10 -r zap-report.html -w zap-report.md -J zap-report.json -x zap-report.xml
        continue-on-error: true

      - name: ZAP Scan Results
        if: always()
        run: |
          echo "ðŸ“Š ZAP scan completed"
          ls -la *.html *.md *.json *.xml 2>/dev/null || echo "Some report files may not be generated"
          if [ -f report_html.html ]; then
            echo "âœ… HTML report generated: report_html.html"
          fi
          if [ -f report_md.md ]; then
            echo "âœ… Markdown report generated: report_md.md"
          fi
          if [ -f zap-report.html ]; then
            echo "âœ… ZAP HTML report generated: zap-report.html"
          fi
          if [ -f zap-report.json ]; then
            echo "âœ… ZAP JSON report generated: zap-report.json"
          fi

      - name: Upload ZAP Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-reports
          path: |
            report_html.html
            report_md.md
            zap-report.html
            zap-report.md
            zap-report.json
            zap-report.xml
          if-no-files-found: warn
          retention-days: 30
